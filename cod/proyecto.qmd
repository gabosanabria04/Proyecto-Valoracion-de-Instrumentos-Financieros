---
title: "Evaluación Actuarial - Smart Investments S.A."
author:
- Paola Espinoza Hernández
- Gabriel Sanabria Alvarado
- Joseph Romero
output:
  pdf_document:
    latex_engine: xelatex
    toc: yes
    number_sections: yes
  html_document:
    toc: yes
    df_print: paged
---

```{r cargar curva cero cupón}
curva <- read.csv("../data/Curva_0C.csv", sep = ";", col.names = c("vencimiento", "colones", "dolares"), dec = ",")
```

# Sección I: Valoración de portafolio
## Árboles de Precio
```{r}
arbol_precios <- function(S0, u, d, N) {
  tree <- matrix(NA_real_, nrow = N + 1, ncol = N + 1)
  for (j in 0:N) {
    for (i in 0:j) {
      tree[i + 1, j + 1] <- S0 * u^(j - i) * d^i
    }
  }
  
  colnames(tree) <- paste0("t", 0:N)
  rownames(tree) <- paste0("downs_", 0:N)
  
  return(tree)
}
```
```{r}
S0 <- 100   
u  <- 1.1   
d  <- 0.9   
N  <- 3     

arbol <- arbol_precios(S0, u, d, N)
arbol

```

## Árbol de Tasa Corta
```{r}
arbol_tasa_descuento <- function(r0, u, d, N, dt = 1, 
                                 tipo = c("continua", "simple")) {
  tipo <- match.arg(tipo)
  
  tasa      <- matrix(NA_real_, nrow = N, ncol = N)
  descuento <- matrix(NA_real_, nrow = N, ncol = N)
  
  for (t in 0:(N - 1)) {
    for (i in 0:t) {
      r_ti <- r0 * u^(t - i) * d^i
      tasa[i + 1, t + 1] <- r_ti
      
      if (tipo == "continua") {
        descuento[i + 1, t + 1] <- exp(-r_ti * dt)
      } else { # tipo == "simple"
        descuento[i + 1, t + 1] <- 1 / (1 + r_ti * dt)
      }
    }
  }
  
  colnames(tasa)      <- paste0("t", 0:(N - 1))
  rownames(tasa)      <- paste0("downs_", 0:(N - 1))
  colnames(descuento) <- colnames(tasa)
  rownames(descuento) <- rownames(tasa)
  
  return(list(tasa = tasa, descuento = descuento))
}
```

```{r}
r0 <- 0.05   
u  <- 1.2   
d  <- 0.8   
N  <- 3      

arbol <- arbol_tasa_descuento(r0, u, d, N, dt = 1, tipo = "continua")

arbol$tasa       # árbol de tasas cortas
arbol$descuento  # árbol de factores D(t, t+1)
```

```{r}
# Árbol binomial conjunto (acción + tasa)
# S0   : precio inicial de la acción
# r0   : tasa inicial
# uS,dS: factores de subida/bajada para la acción
# uR,dR: factores de subida/bajada para la tasa
# N    : número de pasos
# qS   : probabilidad (o vector de long. N) de subida de la acción en cada paso
# qR   : probabilidad (o vector de long. N) de subida de la tasa en cada paso
#
# Devuelve una lista "nodos_por_tiempo":
#   nodos_por_tiempo[[t+1]] es un data.frame con los nodos en el tiempo t:
#     - id        : identificador del nodo
#     - parent_id : id del nodo padre
#     - t         : tiempo (0,1,...,N)
#     - S         : precio de la acción en el nodo
#     - r         : tasa en el nodo
#     - prob      : probabilidad acumulada de llegar al nodo

arbol_binomial_conjunto <- function(S0, r0, uS, dS, uR, dR, N, qS, qR) {
  qS <- rep_len(qS, N)
  qR <- rep_len(qR, N)
  
  nodos_por_tiempo <- vector("list", N + 1)
  
  nodos_por_tiempo[[1]] <- data.frame(
    id        = 1L,
    parent_id = NA_integer_,
    t         = 0L,
    S         = S0,
    r         = r0,
    prob      = 1
  )
  
  id_actual <- 1L
  
  for (t in 1:N) {
    padres <- nodos_por_tiempo[[t]]
    hijos_list <- vector("list", nrow(padres) * 4)
    k <- 1L
    
    for (i in seq_len(nrow(padres))) {
      nodo <- padres[i, ]
      pS <- qS[t]
      pR <- qR[t]
      
      # 1) Acción ↑, Tasa ↑
      id_actual <- id_actual + 1L
      hijos_list[[k]] <- data.frame(
        id        = id_actual,
        parent_id = nodo$id,
        t         = t,
        S         = nodo$S * uS,
        r         = nodo$r * uR,
        prob      = nodo$prob * pS * pR
      ); k <- k + 1L
      
      # 2) Acción ↑, Tasa ↓
      id_actual <- id_actual + 1L
      hijos_list[[k]] <- data.frame(
        id        = id_actual,
        parent_id = nodo$id,
        t         = t,
        S         = nodo$S * uS,
        r         = nodo$r * dR,
        prob      = nodo$prob * pS * (1 - pR)
      ); k <- k + 1L
      
      # 3) Acción ↓, Tasa ↑
      id_actual <- id_actual + 1L
      hijos_list[[k]] <- data.frame(
        id        = id_actual,
        parent_id = nodo$id,
        t         = t,
        S         = nodo$S * dS,
        r         = nodo$r * uR,
        prob      = nodo$prob * (1 - pS) * pR
      ); k <- k + 1L
      
      # 4) Acción ↓, Tasa ↓
      id_actual <- id_actual + 1L
      hijos_list[[k]] <- data.frame(
        id        = id_actual,
        parent_id = nodo$id,
        t         = t,
        S         = nodo$S * dS,
        r         = nodo$r * dR,
        prob      = nodo$prob * (1 - pS) * (1 - pR)
      ); k <- k + 1L
    }
    
    nodos_por_tiempo[[t + 1]] <- do.call(rbind, hijos_list)
  }
  
  return(nodos_por_tiempo)
}

```

```{r}
S0 <- 100
r0 <- 0.05

uS <- 1.1
dS <- 0.9
uR <- 1.2
dR <- 0.8

N  <- 5
qS <- 0.6  
qR <- 0.5  

arbol <- arbol_binomial_conjunto(S0, r0, uS, dS, uR, dR, N, qS, qR)

arbol[[1]]  
arbol[[2]]  
arbol[[3]]  

```

## Árbol conjunto para simulación
```{r}
# Simula UN camino en el árbol conjunto (acción + tasa)
# y devuelve el valor del portafolio en ciertos horizontes.
#
# S0, r0 : valores iniciales de acción y tasa
# uS,dS  : factores up/down de la acción
# uR,dR  : factores up/down de la tasa
# qS,qR  : prob. de subida de acción y tasa (escalares o vectores)
# dt     : tamaño de paso en años (ej. 0.5 si cada paso = 6 meses)
# horizontes : vector de tiempos (en años) donde quieres el valor (ej. c(0,2.5,5,10,15))
# valor_portafolio : función que recibe (S, r, t) y devuelve el valor del portafolio
#
# Devuelve un data.frame con columnas:
# horizonte, paso, S, r, valor

simular_camino_portafolio <- function(S0, r0,
                                      uS, dS,
                                      uR, dR,
                                      qS, qR,
                                      dt,
                                      horizontes,
                                      valor_portafolio) {
  # número de pasos necesario para llegar al máximo horizonte
  N_exact <- max(horizontes) / dt
  if (abs(N_exact - round(N_exact)) > 1e-8) {
    stop("max(horizontes) / dt debe ser un entero exacto.")
  }
  N <- as.integer(round(N_exact))
  
  # asegurar longitud de qS y qR
  qS <- rep_len(qS, N)
  qR <- rep_len(qR, N)
  
  # vectores para el camino
  S <- numeric(N + 1)
  r <- numeric(N + 1)
  tiempos <- dt * (0:N)
  
  S[1] <- S0
  r[1] <- r0
  
  # simular el camino
  for (k in 1:N) {
    upS <- runif(1) < qS[k]
    upR <- runif(1) < qR[k]
    
    S[k + 1] <- S[k] * if (upS) uS else dS
    r[k + 1] <- r[k] * if (upR) uR else dR
  }
  
  # índices de los horizontes en pasos
  pasos <- round(horizontes / dt)
  idx <- pasos + 1  # porque S[1] es t = 0
  
  valores <- mapply(
    FUN = valor_portafolio,
    S   = S[idx],
    r   = r[idx],
    t   = horizontes
  )
  
  data.frame(
    horizonte = horizontes,
    paso      = pasos,
    S         = S[idx],
    r         = r[idx],
    valor     = valores
  )
}

```

```{r}
set.seed(123)

S0 <- 100
r0 <- 0.05
uS <- 1.1; dS <- 0.9
uR <- 1.1; dR <- 0.9
qS <- 0.6
qR <- 0.5
dt <- 1/12
horizontes <- c(0, 2.5, 5, 10, 15)  # años

# Supongamos un portafolio con:
#  - n acciones
#  - un bono cero cupón de nominal B que vence a los 15 años
n_acc <- 50
B_nom <- 1000

valor_portafolio <- function(S, r, t) {
  n_acc * S + B_nom * exp(-r * (15 - t))
}



simular_portafolio_df <- function(n_sim,
                                  S0, r0,
                                  uS, dS,
                                  uR, dR,
                                  qS, qR,
                                  dt,
                                  horizontes,
                                  valor_portafolio) {
  mat <- replicate(
    n_sim,
    simular_camino_portafolio(
      S0, r0,
      uS, dS,
      uR, dR,
      qS, qR,
      dt,
      horizontes,
      valor_portafolio
    )$valor
  )
  
  df <- as.data.frame(t(mat))
  
  colnames(df) <- paste0("t_", horizontes)
  
  df$sim <- seq_len(n_sim)
  df <- df[, c("sim", paste0("t_", horizontes))]
  
  return(df)
}


```

```{r}
set.seed(123)

S0 <- 100
r0 <- 0.05
uS <- 1.1; dS <- 0.9
uR <- 1.1; dR <- 0.9
qS <- 0.6
qR <- 0.5
dt <- 0.5
horizontes <- c(0, 2.5, 5, 10, 15)

valor_portafolio <- function(S, r, t) {
  50 * S + 1000 * exp(-r * (15 - t))
}

res_df <- simular_portafolio_df(
  n_sim = 1000,
  S0, r0,
  uS, dS,
  uR, dR,
  qS, qR,
  dt,
  horizontes,
  valor_portafolio
)

head(res_df)

```

